<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dire: What is DIRE?</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dire<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">A library for Dynamically Interpreted Reflection Expressions (DIRE).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">What is DIRE? </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> DIRE is a C++17 dynamic reflection framework that provides usual features found in a game engine's reflection toolbox:</p>
<ul>
<li>"Smart" Enum types (Sequential Enum and Bitmask Enum, similar to Unreal's UENUM)</li>
<li>Properties (and property metadata, similar to Unreal's UPROPERTY)</li>
<li>Functions (similar to Unreal's UFUNCTION)</li>
<li>Subclass (similar to Unreal's TSubclassOf&lt;T&gt;)</li>
<li>Reflectables (similar to Unreal's UObject)</li>
<li>Can provide Self (for the class itself) and Super (for parent class) typedefs</li>
<li>De/Serialization API (JSON and binary formats)</li>
<li>CRUD access to properties via string representation (think of it as a poor man's Boost.Spirit)</li>
<li>Stateful TypeInfo Database that can be exported to/imported from a file to restore reflectable type information for each type</li>
<li>Doesn't rely on RTTI to work.</li>
</ul>
<p>Some minor features need C++20 to work (i.e. DisplayName or FValueRange metadata types) but the only real requirement is C++17.</p>
<p>The name stands for Dynamically Interpreted Reflection Expressions (or Deeply Insane Reflection Experiment, depending on how you look at it).</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Examples</h1>
<p>Some examples of what you can do with DIRE (adapted from the unit tests):</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Bitmask enums</h2>
<div class="fragment"><div class="line">DIRE_BITMASK_ENUM(BitEnum, <span class="keywordtype">int</span>, one, two, four, eight);</div>
<div class="line"> </div>
<div class="line">BitEnum be = BitEnum::two;</div>
<div class="line">std::string str = be.GetString(); <span class="comment">// &quot;two&quot;</span></div>
<div class="line"> </div>
<div class="line">str = <span class="stringliteral">&quot;one | two | four&quot;</span>;</div>
<div class="line">BitEnum test = BitEnum::GetValueFromString(oredValues);</div>
<div class="line">assert(be.IsBitSet(BitEnum::one) &amp;&amp; be.IsBitSet(BitEnum::two) &amp;&amp; be.IsBitSet(BitEnum::four) &amp;&amp; !be.IsBitSet(BitEnum::eight));</div>
<div class="line"> </div>
<div class="line">BitEnum testops = BitEnum::one;</div>
<div class="line">testops |= BitEnum::two;</div>
<div class="line">assert(testops.IsBitSet(BitEnum::one) &amp;&amp; testops.IsBitSet(BitEnum::two) &amp;&amp; !testops.IsBitSet(BitEnum::four) &amp;&amp; !testops.IsBitSet(BitEnum::eight));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Regular sequential enums (with superpowers)</h2>
<div class="fragment"><div class="line">DIRE_SEQUENTIAL_ENUM(TestEnum, <span class="keywordtype">int</span>, one, two, three, four);</div>
<div class="line"> </div>
<div class="line">TestEnum fromString = *TestEnum::GetValueFromString(<span class="stringliteral">&quot;one&quot;</span>);</div>
<div class="line">assert(fromString == TestEnum::one);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::string&gt; strings;</div>
<div class="line">std::vector&lt;std::string&gt; goodStrings{<span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;three&quot;</span>, <span class="stringliteral">&quot;four&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> check = 0;</div>
<div class="line">TestEnum::Enumerate([&amp;](TestEnum value)</div>
<div class="line">{</div>
<div class="line">    assert(check == value.Value);</div>
<div class="line">    check++;</div>
<div class="line">    strings.push_back(value.GetString());</div>
<div class="line">});</div>
<div class="line">assert(strings == goodStrings);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Property manipulation</h2>
<div class="fragment"><div class="line">dire_reflectable(<span class="keyword">struct</span> testcompound)</div>
<div class="line">{</div>
<div class="line">    testcompound() = <span class="keywordflow">default</span>;</div>
<div class="line">    </div>
<div class="line">    DIRE_REFLECTABLE_INFO()</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY(<span class="keywordtype">int</span>, answerTwice, 0x2a2a)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">dire_reflectable(struct b)</div>
<div class="line">{</div>
<div class="line">    DIRE_REFLECTABLE_INFO()</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY(testcompound, aMemberStruct)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">dire_reflectable(struct c, b) <span class="comment">// c inherits from b</span></div>
<div class="line">{</div>
<div class="line">    c() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    DIRE_REFLECTABLE_INFO()</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY(<span class="keywordtype">unsigned</span>, anErrorCode, 0xDEADBEEF)</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY((std::vector&lt;<span class="keywordtype">int</span>&gt;), aVector, std::initializer_list&lt;<span class="keywordtype">int</span>&gt;{1, 2, 3})</div>
<div class="line"> </div>
<div class="line">    DIRE_ARRAY_PROPERTY(<span class="keywordtype">int</span>, anArray, [10])</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY((std::map&lt;<span class="keywordtype">int</span>, <span class="keywordtype">bool</span>&gt;), anEvenOddMap);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">c aC;</div>
<div class="line">const <span class="keywordtype">unsigned</span> * error = aC.GetProperty&lt;<span class="keywordtype">unsigned</span>&gt;(&quot;anErrorCode&quot;);</div>
<div class="line">assert(*compu == 0xDEADBEEF);</div>
<div class="line"> </div>
<div class="line">const <span class="keywordtype">int</span> * answerTwice = aC.GetProperty&lt;<span class="keywordtype">int</span>&gt;(&quot;aMemberStruct.answerTwice&quot;);</div>
<div class="line">REQUIRE(*answerTwice == 0x2a2a);</div>
<div class="line"> </div>
<div class="line">aC.anArray[5] = &#39;*&#39;;</div>
<div class="line">const <span class="keywordtype">char</span>* ch = aC.GetProperty&lt;<span class="keywordtype">char</span>&gt;(&quot;anArray[5]&quot;);</div>
<div class="line">REQUIRE(*ch == &#39;*&#39;);</div>
<div class="line"> </div>
<div class="line">const <span class="keywordtype">int</span>* veci = aC.GetProperty&lt;<span class="keywordtype">int</span>&gt;(&quot;aVector[1]&quot;);</div>
<div class="line">assert(*val == 2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> modified = aC.SetProperty&lt;<span class="keywordtype">bool</span>&gt;(&quot;aEvenOddMap[1]&quot;, true);</div>
<div class="line">assert(modified &amp;&amp; aC.aEvenOddMap[1] == true);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Type introspection</h2>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>testNS</div>
<div class="line">{</div>
<div class="line">    dire_reflectable(<span class="keyword">struct</span> Nested)</div>
<div class="line">    {</div>
<div class="line">        DIRE_REFLECTABLE_INFO()</div>
<div class="line"> </div>
<div class="line">        int TheAnswer()</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> 42;</div>
<div class="line">        }</div>
<div class="line">        DIRE_FUNCTION_TYPEINFO(TheAnswer);</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">dire_reflectable(<span class="keyword">struct</span> SubCompound)</div>
<div class="line">{</div>
<div class="line">    DIRE_REFLECTABLE_INFO()</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY(<span class="keywordtype">float</span>, aUselessProp, 4.f)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">dire_reflectable(struct Compound)</div>
<div class="line">{</div>
<div class="line">    DIRE_REFLECTABLE_INFO()</div>
<div class="line"> </div>
<div class="line">    DIRE_PROPERTY(<span class="keywordtype">int</span>, leet, 1337);</div>
<div class="line">    DIRE_PROPERTY(SubCompound, sub);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reusing the b and c types from previous example...</span></div>
<div class="line"> </div>
<div class="line">c aC;</div>
<div class="line">assert(aC.IsA&lt;b&gt;());</div>
<div class="line">static_assert(std::is_same_v&lt;c::Self, c&gt;);</div>
<div class="line">static_assert(std::is_same_v&lt;c::Super, b&gt;);</div>
<div class="line"> </div>
<div class="line">assert(b::GetTypeInfo().GetName() == &quot;b&quot;);</div>
<div class="line">assert(c::GetTypeInfo().GetName() == &quot;c&quot;);</div>
<div class="line">assert(testNS::Nested::GetTypeInfo().GetName() == &quot;testNS::Nested&quot;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// generic instantiate</span></div>
<div class="line">dire::Subclass&lt;b&gt; aSubClass;</div>
<div class="line">assert(aSubClass.GetClassID() == b::GetTypeInfo().GetID());</div>
<div class="line"> </div>
<div class="line">aSubClass.SetClass(c::GetTypeInfo().GetID());</div>
<div class="line">assert(aSubClass.GetClassID() == c::GetTypeInfo().GetID());</div>
<div class="line">b* newB = aSubClass.Instantiate();</div>
<div class="line">assert((<span class="keywordtype">nullptr</span> != newB &amp;&amp; dynamic_cast&lt;c*&gt;(newB) != <span class="keywordtype">nullptr</span>));</div>
<div class="line">delete newB; <span class="comment">// So far, Instantiate is handled with new, so deleting the allocated pointer is up to the caller.</span></div>
<div class="line"> </div>
<div class="line">testNS::Nested aNested;</div>
<div class="line"><span class="keywordtype">int</span> answer = dire::Invoke&lt;<span class="keywordtype">int</span>&gt;(&quot;TheAnswer&quot;, aNested);</div>
<div class="line">assert(answer == 42);</div>
<div class="line"> </div>
<div class="line">Compound clonedComp;</div>
<div class="line">clonedComp.leet = 123456789;</div>
<div class="line">clonedComp.sub.aUselessProp = 42.f;</div>
<div class="line">Compound* clone = clonedComp.Clone&lt;Compound&gt;();</div>
<div class="line">assert(clone &amp;&amp; clone-&gt;leet == clonedComp.leet &amp;&amp; clone-&gt;sub.aUselessProp == clonedComp.sub.aUselessProp &amp;&amp; &amp;clone-&gt;leet != &amp;clonedComp.leet);</div>
<div class="line">delete clone; <span class="comment">// So far, Cloning is handled with new, so deleting the pointer is up to the caller.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Serialization</h2>
<div class="fragment"><div class="line"><span class="comment">// Reusing Compound from previous example...</span></div>
<div class="line"> </div>
<div class="line">dire::JsonReflectorSerializer serializer;</div>
<div class="line">dire::JsonReflectorDeserializer deserializer;</div>
<div class="line">std::string serialized;</div>
<div class="line"> </div>
<div class="line">Compound clonedComp;</div>
<div class="line">clonedComp.leet = 123456789;</div>
<div class="line">clonedComp.sub.aUselessProp = 42.f;</div>
<div class="line"> </div>
<div class="line">serialized = serializer.Serialize(clonedComp).AsString();</div>
<div class="line">assert(serialized == <span class="stringliteral">&quot;{\&quot;leet\&quot;:123456789,\&quot;sub\&quot;:{\&quot;aUselessProp\&quot;:42.0}}&quot;</span>);</div>
<div class="line"> </div>
<div class="line">Compound deserializedClonedComp;</div>
<div class="line">deserializer.DeserializeInto(serialized.data(), deserializedClonedComp);</div>
<div class="line">assert(deserializedClonedComp.leet == clonedComp.leet &amp;&amp; deserializedClonedComp.sub.aUselessProp == clonedComp.sub.aUselessProp);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or...</span></div>
<div class="line"> </div>
<div class="line">dire::BinaryReflectorSerializer serializer;</div>
<div class="line">dire::BinaryReflectorDeserializer deserializer;</div>
<div class="line"> </div>
<div class="line">Compound clonedComp;</div>
<div class="line">clonedComp.leet = 123456789;</div>
<div class="line">clonedComp.copyable.aUselessProp = 42.f;</div>
<div class="line"> </div>
<div class="line">dire::ISerializer::Result serializedBytes = serializer.Serialize(clonedComp);</div>
<div class="line"><span class="keyword">auto</span> binarized = serializedBytes.GetBytes();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> expectedResult[] = </div>
<div class="line">    <span class="stringliteral">&quot;\x06\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x0c\x00\x00\x00\x15\xcd\x5b\x07\x0c\x00\x00\x00\x10\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\x00\x00\x28\x42&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> expectedVec = std::vector&lt;std::byte&gt;((<span class="keyword">const</span> std::byte*)expectedResult, (<span class="keyword">const</span> std::byte*)expectedResult + <span class="keyword">sizeof</span> expectedResult - 1);</div>
<div class="line">assert(binarized == expectedVec);</div>
<div class="line"> </div>
<div class="line">Compound deserializedClonedComp;</div>
<div class="line">deserializer.DeserializeInto((<span class="keyword">const</span> <span class="keywordtype">char</span>*)binarized.data(), deserializedClonedComp);</div>
<div class="line">assert(deserializedClonedComp.leet == clonedComp.leet &amp;&amp; deserializedClonedComp.copyable.aUselessProp == clonedComp.copyable.aUselessProp);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
What does it need?</h1>
<p>A C++17-able compiler. An non-exhaustive list of used features follows:</p><ul>
<li>std::any</li>
<li>std::optional</li>
<li>std::variant</li>
<li>std::from_chars</li>
<li>structured bindings</li>
<li>[[nodiscard]]</li>
</ul>
<p>Some metadata types, namely FValueRange and DisplayName, also require C++20 to be used.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
What are the limitations?</h1>
<p>There are some things to bear in mind when using DIRE:</p>
<ul>
<li>All classes who inherit Reflectable become virtual because of its pure functions. It means that it will make your classes non-standard layout, and a bit heavier because of the virtual table pointer. Since the TypeInfo database and Reflectables are two separate entities, it should be possible to address that issue in the future.</li>
<li>Using DIRE could also increase the program's startup time, because of the static initialization machinery needed to initialize everything. Granted, it's also going to make your executable size bigger, because more static memory will have to be bundled into it.</li>
<li>DIRE relies a lot on virtual function calls. Yhose are known for being more expensive to call than regular functions. Modern compilers are however getting better at devirtualizing virtual function calls, so: YMMV.</li>
<li>DIRE uses a fair amount of macros and complex templates to work. As a result, I've seen measurable increases in compile time by using it. I'm currently trying to address this.</li>
<li>DIRE does not support template reflectables at the moment (if you try, it's going to cause syntax errors and won't compile).</li>
<li>The de/serialization API is at the proof-of-concept stage right now, and could use some optimization.</li>
<li>Always keep in mind that:<ul>
<li>I have a full-time job, so I will support this library "when I can".</li>
<li>This project is experimental.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
License</h1>
<p>This library is licensed under the LGPL.</p>
<p>In other words, any usage is allowed, even for commercial purpose.</p>
<p>But if you modify the library to make improvements, those improvements have to go back to the public domain.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
But... Why?</h1>
<p>Because it's a fun hobby project. :-)</p>
<p>DIRE's feature set was inspired by the various game engines I use (Unity, Unreal Engine...). I programmed a lot with the Unreal Engine, so that's why the features of DIRE were heavily inspired by it. I wanted to be able to reproduce as many features as I could from UE in my personal game engine project.</p>
<p>It may not be <em>perfect</em>,but it seems to me that the other reflection libraries' don't really overlap with what I actually want. Most C++17/20 reflection libraries are impressively easy to use when the serialized type is known at compile-time (thanks to templates). But if we're dealing with dynamic objects that are only a pointer to an interface, they cannot use templates anymore.</p>
<p>And I don't want to add a big dependency like Boost to my project, and <em>still</em> have a lot to program myself on top of it anyway.</p>
<p>In a game engine, it's pretty common to work with abstracted types, especially while communicating with a game editor. When the editor sends an updated property sheet, I want to be able to use an abstraction layer that deals with the updating without knowing what type of object are we actually modifying.</p>
<p>Thanks to the fact that DIRE is able to create, update and delete properties just by parsing text, I don't have to know the type of object I'm editing in advance. All I need to know is that it's a Reflectable!</p>
<p>On the other hand, I want to have a solution to serialize the properties of an object without having to know its actual type, so that I can write generic serialization code that only relies on the Reflectable interface.</p>
<p>DIRE is able to do that in two formats: JSON (mostly useful to communicate back and forth with a game editor) and binary (mostly useful for packaged games).</p>
<p>Hence, DIRE was born. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
